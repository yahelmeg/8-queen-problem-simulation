Object subclass: #Board	instanceVariableNames: 'lastQueen boardMorph'	classVariableNames: ''	poolDictionaries: ''	category: 'Maman13Updated'!!Board methodsFor: 'solve' stamp: 'aaaaaaaa 1/11/2023 15:27'!solve	| solutionPositions | 			Transcript clear.	(lastQueen firstSolution)	ifTrue: [		solutionPositions := lastQueen result.		boardMorph presentSolution: solutionPositions.		Transcript show: lastQueen result printString; cr.		[lastQueen nextSolution] whileTrue: [			solutionPositions := lastQueen result.			boardMorph presentSolution: solutionPositions.			Transcript show: lastQueen result printString; cr.			].		Transcript show:'End of Solutions';cr.]	ifFalse:[Transcript show:		'No Solution';cr.]! !!Board methodsFor: 'initialization' stamp: 'aaaaaaaa 1/11/2023 11:51'!initialize	boardMorph := BoardMorph new.	lastQueen := QueenTerminator new.	(1 to: 8) do: [ :i | 		lastQueen := Queen new setColumn: i neighbour: lastQueen.		lastQueen currentCell:(boardMorph getCellAtRow:1 atCol:i).		(lastQueen currentCell) addQueen.		]! !BorderedMorph subclass: #BoardMorph	instanceVariableNames: 'boardWidth boardHeight cellsMatrix'	classVariableNames: ''	poolDictionaries: ''	category: 'Maman13Updated'!!BoardMorph methodsFor: 'initialization' stamp: 'aaaaaaaa 1/12/2023 11:17'!initialize	| sampleCell cellWidth cellHeight newCell RowOfCellsMorph |	super initialize.	sampleCell := self createCellAtRow:1 Col: 1.	cellWidth := sampleCell width.	cellHeight := sampleCell height.	boardWidth := (8*cellWidth).	boardHeight := (8*cellHeight).	self position: 100@100.	self extent: boardWidth@boardHeight.	self layoutPolicy: TableLayout new.	self listDirection: #topToBottom.	self listCentering: #topLeft.	self wrapCentering: #center.	self hResizing: #spaceFill.	self vResizing: #spaceFill.	self color: Color black.	self openInWorld.	cellsMatrix := Matrix new: 8.	1 to: 8 do: [ :row |		RowOfCellsMorph := Morph new layoutPolicy: TableLayout new.		RowOfCellsMorph listDirection: #rightToLeft.		RowOfCellsMorph extent: boardWidth@cellHeight.		RowOfCellsMorph listCentering: #topLeft.		RowOfCellsMorph wrapCentering: #center.		1 to: 8 do: [ :col |			newCell := self createCellAtRow: row Col: col.			cellsMatrix at: row at: col put: newCell.			RowOfCellsMorph addMorph: newCell.		].		self addMorph: RowOfCellsMorph.	].	self setCellNeighbours.! !!BoardMorph methodsFor: 'getters' stamp: 'aaaaaaaa 1/10/2023 13:12'!getCellAtRow: i atCol: j	^cellsMatrix at: i at: j! !!BoardMorph methodsFor: 'solution presentation' stamp: 'aaaaaaaa 1/12/2023 23:36'!presentSolution: aSolution	"display the solution by changing the queen color to blue"		(1 to: 8) do: [:i|		(cellsMatrix at: (aSolution at:i) at: i) removeQueen.		(cellsMatrix at: (aSolution at:i) at: i) addSolutionQueen.		].	World doOneCycle.	5 seconds asDelay wait.	(1 to: 8) do: [:i|		(cellsMatrix at: (aSolution at:i) at: i) addQueen.		(cellsMatrix at: (aSolution at:i) at: i) removeSolutionQueen.		].! !!BoardMorph methodsFor: 'setters' stamp: 'aaaaaaaa 1/11/2023 11:42'!createCellAtRow: i Col: j	| remainder |	remainder:= ((i+j) rem: 2).	^((CellMorph new) initializeColor:remainder)	! !!BoardMorph methodsFor: 'setters' stamp: 'aaaaaaaa 1/12/2023 23:36'!setCellNeighbours	"set neighbours of each cell in the cell matrix"	| upCell upRightCell rightCell downRightCell downLeftCell leftCell upLeftCell |		(1 to: 8) do: [:r |		(1 to: 8) do: [:c |				upCell := nil.			upRightCell := nil.		rightCell := nil.		downRightCell := nil.		downLeftCell := nil.		leftCell :=nil.		upLeftCell :=nil.						(r=1 and: c=1)			ifTrue: [				upCell := cellsMatrix at:(r+1) at: c.				upRightCell := cellsMatrix at:(r+1) at: (c+1).				rightCell := cellsMatrix at:r at: c+1.				].			( (r=8) and: (c=1) )			ifTrue: [				upCell := cellsMatrix at:1 at: c.				downRightCell := cellsMatrix at:(r-1) at: c+1.				rightCell := cellsMatrix at:r at: (c+1).				].			( (r=1) and: (c=8) )			ifTrue: [				upCell := cellsMatrix at:(r+1) at: c.				upLeftCell := cellsMatrix at:(r+1) at: (c-1).				leftCell := cellsMatrix at:r at: c-1.				].			( (r=8) and: (c=8) )			ifTrue: [				upCell := cellsMatrix at:1 at: c.				downLeftCell := cellsMatrix at:(r-1) at: (c-1).				leftCell := cellsMatrix at:r at: (c-1).				].			( (r=1) and: (c~=1) and: (c~=8) )				ifTrue: [				upCell := cellsMatrix at:(r+1) at: c.				leftCell  := cellsMatrix at:r at: (c-1).				upLeftCell := cellsMatrix at:(r+1) at: (c-1).				upRightCell := cellsMatrix at:(r+1) at: (c+1).				rightCell := cellsMatrix at:r at: (c+1).				].			( (r=8) and: (c~=1) and: (c~=8) )				ifTrue: [				upCell := cellsMatrix at:1 at: c.				leftCell  := cellsMatrix at:r at: (c-1).				downLeftCell := cellsMatrix at:(r-1) at: (c-1).				downRightCell := cellsMatrix at:(r-1) at: (c+1).				rightCell := cellsMatrix at:r at: (c+1).				].			( (c=1) and: (r~=1) and: (r~=8) )				ifTrue: [				upCell := cellsMatrix at:(r+1) at: c.				upRightCell := cellsMatrix at:(r+1) at: (c+1).				rightCell := cellsMatrix at:r at: (c+1).				downRightCell := cellsMatrix at:(r-1) at: (c+1).				].			( (c=8) and: (r~=1) and: (r~=8) )			ifTrue: [				upCell := cellsMatrix at:(r+1) at: c.				upLeftCell := cellsMatrix at:(r+1) at: (c-1).				leftCell := cellsMatrix at:r at: (c-1).				downLeftCell := cellsMatrix at:(r-1) at: (c-1).				].				( (c~=1) and: (c~=8) and: (r~=1) and: (r~=8) )			ifTrue:[				upCell := cellsMatrix at:(r+1) at: c.				upRightCell := cellsMatrix at:(r+1) at: (c+1).				rightCell := cellsMatrix at:r at: (c+1).				downRightCell := cellsMatrix at:(r-1) at: (c+1).				downLeftCell := cellsMatrix at:(r-1) at: (c-1).				leftCell := 	 cellsMatrix at:r at: (c-1).				upLeftCell := cellsMatrix at:(r+1) at: (c-1).				].						(cellsMatrix at: r at: c) neighbourCellsUp: upCell upRight: upRightCell right: rightCell downRight: downRightCell downLeft: downLeftCell left: leftCell upLeft: upLeftCell.			]		]! !ImageMorph subclass: #CellMorph	instanceVariableNames: 'cellWidth cellHeight neighbourCells queen cross highlight solutionQueen'	classVariableNames: ''	poolDictionaries: ''	category: 'Maman13Updated'!!CellMorph methodsFor: 'add image' stamp: 'aaaaaaaa 1/11/2023 18:07'!addCross	cross := (ImageMorph new newForm: ((ImageReadWriter formFromFileNamed: 'cross.png' ) magnifyBy: 0.2)).	self addMorphFront: cross.	cross center: self center.	World doOneCycle. 	0.05 seconds asDelay wait.! !!CellMorph methodsFor: 'add image' stamp: 'aaaaaaaa 1/11/2023 15:50'!addHighlight	highlight := (ImageMorph new newForm: ((ImageReadWriter formFromFileNamed: 'highlight.png' ) magnifyBy: 0.25)).	self addMorphFront: highlight.	highlight center: self center.	World doOneCycle. 	0.1 seconds asDelay wait.! !!CellMorph methodsFor: 'add image' stamp: 'aaaaaaaa 1/11/2023 15:50'!addQueen	queen := (ImageMorph new newForm: ((ImageReadWriter formFromFileNamed: 'queen.png' ) magnifyBy: 0.1)).	self addMorphFront: queen.	queen center: self center.	World doOneCycle. 	0.1 seconds asDelay wait.! !!CellMorph methodsFor: 'add image' stamp: 'aaaaaaaa 1/11/2023 15:37'!addSolutionQueen	solutionQueen := (ImageMorph new newForm: ((ImageReadWriter formFromFileNamed: 'solutionQueen.png' ) magnifyBy: 0.1)).	self addMorphFront: solutionQueen.	solutionQueen center: self center.	World doOneCycle. 	0.1 seconds asDelay wait.! !!CellMorph methodsFor: 'initialization' stamp: 'aaaaaaaa 1/9/2023 15:37'!initialize	super initialize.	cellWidth := 50.	cellHeight := 50.		self width: cellWidth.	self height: cellHeight.	self hResizing: #spaceFill.	self vResizing: #spaceFill.! !!CellMorph methodsFor: 'initialization' stamp: 'aaaaaaaa 1/12/2023 11:17'!initializeColor: aRemainder	self initialize.		(aRemainder = 0)	ifTrue: [self image:(ImageReadWriter formFromFileNamed: 'darkEmpty.png')]	ifFalse: [self image: (ImageReadWriter formFromFileNamed: 'brownEmpty.png')].! !!CellMorph methodsFor: 'accessing' stamp: 'aaaaaaaa 1/11/2023 14:48'!displayLineOfAttackOf: aDirection andDistance: aDistance	(aDistance = 0)	ifTrue: [ self addHighlight]	ifFalse: [	self addCross.	      (neighbourCells at:aDirection) displayLineOfAttackOf: aDirection andDistance: (aDistance-1).	].	(cross ~= nil)	ifTrue:[self removeCross].	(highlight ~= nil)	ifTrue:[self removeHighlight]! !!CellMorph methodsFor: 'setters' stamp: 'aaaaaaaa 1/11/2023 21:24'!neighbourCellsUp: anUpCell upRight: anUpRightCell right: aRightCell downRight: aDownRightCell downLeft: aDownLeftCell left: aLeftCell upLeft: anUpLeftCell	neighbourCells := Dictionary newFrom: {	#up -> anUpCell.	#upRight -> anUpRightCell.	#right -> aRightCell.	#downRight -> aDownRightCell.	#downLeft -> aDownLeftCell.	#left -> aLeftCell.	#upLeft -> anUpLeftCell.	}! !!CellMorph methodsFor: 'remove image' stamp: 'aaaaaaaa 1/10/2023 19:25'!removeCross	self removeMorph:cross.	cross := nil.! !!CellMorph methodsFor: 'remove image' stamp: 'aaaaaaaa 1/10/2023 17:10'!removeHighlight	self removeMorph: highlight.	highlight := nil.! !!CellMorph methodsFor: 'remove image' stamp: 'aaaaaaaa 1/10/2023 17:08'!removeQueen	self removeMorph:queen.	queen := nil.! !!CellMorph methodsFor: 'remove image' stamp: 'aaaaaaaa 1/11/2023 15:38'!removeSolutionQueen	self removeMorph:solutionQueen.	solutionQueen := nil.! !!CellMorph methodsFor: 'getters' stamp: 'aaaaaaaa 1/9/2023 16:37'!height		^cellHeight! !!CellMorph methodsFor: 'getters' stamp: 'aaaaaaaa 1/10/2023 18:11'!neighbourCells	^neighbourCells! !!CellMorph methodsFor: 'getters' stamp: 'aaaaaaaa 1/9/2023 16:37'!width		^cellWidth! !Object subclass: #Queen	instanceVariableNames: 'row column neighbour currentCell'	classVariableNames: ''	poolDictionaries: ''	category: 'Maman13Updated'!!Queen methodsFor: 'getters' stamp: 'aaaaaaaa 1/11/2023 11:48'!currentCell	^currentCell! !!Queen methodsFor: 'getters' stamp: 'aaaaaaaa 1/12/2023 23:40'!directionFinderAtRow: testRow atCol: testColumn		"returns the direction the queen is attacking from"	| columnDifference directionOfAttack |		columnDifference := testColumn - column.		(row = testRow)  	ifTrue: [		(column < testColumn)		ifTrue:[directionOfAttack := #right]		ifFalse:[directionOfAttack := #left.].		].	(row + columnDifference = testRow)	ifTrue: [		(column < testColumn)		ifTrue:[directionOfAttack := #upRight]		ifFalse:[directionOfAttack := #upLeft.].		].	(row  -  columnDifference = testRow)	ifTrue: [		(column < testColumn)		ifTrue:[directionOfAttack := #downRight]		ifFalse:[directionOfAttack := #downLeft.].		].	^directionOfAttack! !!Queen methodsFor: '8 queen problem solvers' stamp: 'aaaaaaaa 1/11/2023 21:27'!advance	(row = 8)	ifTrue: [ 		(neighbour nextSolution) ifFalse: [^false].		row := 0		].		row := row +1.				currentCell removeQueen.		currentCell := (currentCell neighbourCells at:#up).		currentCell addQueen.				^ true! !!Queen methodsFor: '8 queen problem solvers' stamp: 'aaaaaaaa 1/11/2023 14:39'!canAttack: testRow x: testColumn	| columnDifference directionOfAttack |		columnDifference := testColumn - column.		(( row = testRow  or: [ row + columnDifference = testRow] or: [ row  -  columnDifference = testRow]))	ifTrue: [		directionOfAttack := self directionFinderAtRow: testRow atCol: testColumn.		currentCell addHighlight.		(currentCell neighbourCells at:directionOfAttack) displayLineOfAttackOf: directionOfAttack andDistance: (columnDifference-1).		currentCell removeHighlight.		^true].	^neighbour canAttack: testRow x: testColumn! !!Queen methodsFor: '8 queen problem solvers' stamp: 'aaaaaaaa 1/11/2023 11:35'!firstSolution	neighbour firstSolution.	row := 1.	^ self moveToNextNonAttackedRow! !!Queen methodsFor: '8 queen problem solvers' stamp: 'aaaaaaaa 1/11/2023 11:34'!moveToNextNonAttackedRow	[neighbour canAttack: row x:column]		whileTrue:[self advance ifFalse:[^false]].	^true! !!Queen methodsFor: '8 queen problem solvers' stamp: 'aaaaaaaa 1/11/2023 11:34'!nextSolution	^self advance	and: [self moveToNextNonAttackedRow]! !!Queen methodsFor: '8 queen problem solvers' stamp: 'aaaaaaaa 1/11/2023 12:22'!result	^neighbour result addLast: row; yourself! !!Queen methodsFor: 'setters' stamp: 'aaaaaaaa 1/11/2023 11:49'!currentCell: aCell	currentCell := aCell.! !!Queen methodsFor: 'setters' stamp: 'aaaaaaaa 1/11/2023 11:36'!setColumn: aColumn neighbour: aQueen	column := aColumn.	neighbour := aQueen.! !Object subclass: #QueenTerminator	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Maman13Updated'!!QueenTerminator methodsFor: 'as yet unclassified' stamp: 'aaaaaaaa 1/11/2023 11:37'!canAttack: testRow x: testColumn	^false! !!QueenTerminator methodsFor: 'as yet unclassified' stamp: 'aaaaaaaa 1/11/2023 11:37'!firstSolution		^true! !!QueenTerminator methodsFor: 'as yet unclassified' stamp: 'aaaaaaaa 1/11/2023 11:37'!nextSolution		^false! !!QueenTerminator methodsFor: 'as yet unclassified' stamp: 'aaaaaaaa 1/11/2023 11:37'!result	^OrderedCollection new! !